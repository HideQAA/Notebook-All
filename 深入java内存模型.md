# 深入Java内存模型 #
---
基本概念
---
### **并发** ###

并发需要处理两个关键问题：线程之间如何通信及线程之间如何同步

**通信：**线程之间的通信机制有两种：共享内存和消息传递。

**同步：**是指程序用于控制不同线程之间操作发生相对顺序的机制。在Java中，可以通过volatile，synchronized, 锁等方式实现同步。

### **JMM** ###

![](https://i.imgur.com/SQC7AeX.png)

### **重排序** ###

重排序是指“编译器和处理器”为了提高性能，而在程序执行时会对程序进行的重排序

**分类**：重排序分为“**编译器**”和“**处理器**”两个方面，而“处理器”重排序又包括“**指令级重排序**”和“**内存的重排序**”。

<p style="color:red">为了提高程序的并发度，从而提高性能！但是对于多线程程序，重排序可能会导致程序执行的结果不是我们需要的结果！因此，就需要我们通过“volatile，synchronize，锁等方式”作出正确的实现同步。</p>

### **内存屏障** ###

作用：通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。

<table>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>

</tr>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>

</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td>

</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td>

</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>

</tr>
</table>

### **happens-before** ###

定义：JDK5(JSR-133)提供的概念，用于描述多线程操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。

作用：描述多线程操作之间的内存可见性。

[程序顺序规则]：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。

[监视器锁规则]：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。

[volatile变量规则]：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。

[传递性]：如果A happens- before B，且B happens- before C，那么A happens- before C。

### **as-if-serial** ###

定义：不管怎么重排序，程序的执行结果不能被改变。


### **数据依赖性** ###

定义：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

作用：编译器和处理器不会对“存在数据依赖关系的两个操作”执行重排序。


---
---
同步机制
---
### **volatile** （变量）
---
**特性：**

* **可见性**：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。

* **原子性**：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

**内存语义：**

* **volatile写**：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
* **volatile读:** 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

**内存语义的实现：**

1. 在每个volatile写操作的前面插入一个StoreStore屏障；
2. 在每个volatile写操作的后面插入一个StoreLoad屏障；
3. 在每个volatile读操作的后面插入一个LoadLoad屏障；
4. 在每个volatile读操作的后面插入一个LoadStore屏障。

<p style="color:red">volatile可以保证内存可见性，不能保证并发有序性(对于复合操作不具有原子性)</p>

---

###**锁** （对象）
---
**内存语义：**

* **线程A释放一个锁**，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息,JMM会把线程A对应的本地内存中的共享变量刷新到主内存中；
* **线程B获取一个锁**，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息，JMM会把线程B对应的本地内存置为无效，并从主内存中读取共享变量；

**总结：** 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。

**内存语义的实现：**

* **公平锁：**公平锁在释放锁的最后写volatile变量state；在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。（**公平锁是通过“volatile”实现同步的**）
* **非公平锁：**（**通过CAS实现的，CAS就是compare and swap**）。CAS实际上调用的JNI函数，也就是CAS依赖于本地实现。以Intel来说，对于CAS的JNI实现函数，它保证：(01)禁止该CAS之前和之后的读和写指令重排序。(02)把写缓冲区中的所有数据刷新到内存中。

**总结：**公平锁和非公平锁释放时，最后都要写一个volatile变量state；公平锁获取时，首先会读这个volatile变量；非公平锁获取时，首先会用CAS更新这个volatile变量，这个操作同时具有volatile读和volatile写的内存语义。

**concurrent包源代码的通用实现模式**：
1. 首先，声明共享变量为volatile；
2. 然后，使用CAS的原子条件更新来实现线程之间的同步；
3. 同时，配合以volatile的读写和CAS所具有的volatile读写的内存语义来实现线程之间的通信。

![](https://i.imgur.com/kq8t9m0.png)

---
### **final** ###

---
**特性**

* **基本类型的final域:**
  1.  **final写：** “构造函数内对一个final域的写入”，与“随后把这个被构造对象的引用赋值给一个引用变量”，这两个操作之间不能重排序;(禁止把final域的写重排序到构造函数之外)
  2.  **final读：** “初次读一个包含final域的对象的引用”，与“随后初次读对象的final域”，这两个操作之间不能重排序。
* **引用类型的final域：**（上面两条适用）
  3. 在“构造函数内对一个final引用的对象的成员域的写入”，与“随后在构造函数外把这个被构造对象的引用赋值给一个引用变量”，这两个操作之间不能重排序。


<p style="color:red">写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。</p>
 
**JMM如何实现final:**

在final域的写之后，构造函数return之前，插入一个StoreStore障屏。在读final域的操作前面插入一个LoadLoad屏障。

---
---
总结
---
JMM、处理器内存模型和顺序一致性内存模型对应于语言级、硬件级和理论参考级

JMM的设计示意图：

![](https://i.imgur.com/gv8skzR.png)


内存可见性示意图：

![](https://i.imgur.com/64geC22.png)