<font color='blue'>数据库原理</font>
---
* 数据模型设计原理（应用）

* 存储引擎原理（基础）

* 索引与查询优化器的原理（性能）

* 事务与并发控制的原理（正确性）

* 故障恢复与复制系统的原理（可靠性）

数据库包括各种各样的数据系统组件：

* 数据库：存储数据，以便自己或其他应用程序之后能再次找到（PostgreSQL，MySQL，Oracle）；

* 缓存：记住开销昂贵操作的结果，加快读取速度（Redis，Memcached）；

* 搜索索引：允许用户按关键字搜索数据，或以各种方式对数据进行过滤（ElasticSearch）；

* 流处理：向其他进程发送消息，进行异步处理（Kafka，Flink，Storm）；

* 批处理：定期处理累积的大批量数据（Hadoop）。





一、事务
---
事务指的是满足 ACID 特性的一组操作，可以 **commit** ，也可以 **rollback**

* **A（原子性）**：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚；
* **C（一致性）**：数据库在事务执行前后都保持一致性状态，所有事务对一个数据的读取结果都是相同的；
* **I（隔离性）**：一个事务所做的修改在最终提交以前，对其它事务是不可见的；
* **D（持久性）**：一旦事务提交，则其所做的修改将会永远保存到数据库中。

**ACID关系：**

![](https://i.imgur.com/v07LMZu.png)

并发情况下，隔离和原子都满足，一致才满足；串行情况下，只要满足原子就能满足一致；只有满足一致，执行结果才会是正确的；持久主要应对数据库崩溃的问题。


二、并发一致性问题
---
并发的情况下，事务的一致性会很难保证，会出现很多并发一致性问题

### 丢失修改 ###

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

![](https://i.imgur.com/goZt1aR.png)

### 读脏数据 ###

T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

![](https://i.imgur.com/w37hn9E.png)

### 不可重复读 （update）###

T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

![](https://i.imgur.com/0ii6qsH.png)

### 幻影读 （insert）###

T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

![](https://i.imgur.com/csaCU3S.png)


**解决办法：**

* 事务的隔离级别
* 通过封锁来实现的并发控制

三、隔离级别
---
### 未提交读（READ UNCOMMITTED） 全都没法避免 ###

事务中的修改，即使没有提交，对其它事务也是可见的

### 提交读（READ COMMITTED） 避免脏读###

一个事务只能读取已经提交的事务所做的修改，在提交之前对其它事务是不可见的

### 可重复读（REPEATABLE READ） 避免脏读和不可重复读###

保证在同一个事务中多次读取同样数据的结果是一样的

### 可串行化（SERIALIZABLE） 避免所有的问题###

强制事务串行执行


四、封锁
---

